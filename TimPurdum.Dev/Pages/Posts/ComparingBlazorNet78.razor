@page "/post/2023/10/14/comparing-blazor-net-7-8"
<PageTitle>Comparing Blazor Project Structure in .NET 7 and 8</PageTitle>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
    <header class="post-header">
        <h1 class="post-title p-name" itemprop="name headline">Comparing Blazor Project Structure in .NET 7 and 8</h1>
        <h2 class="post-subtitle" itemprop="name subtitle">Understanding How to Set Up or Update a Complex Project</h2>
        <p class="post-meta">
            <time class="dt-published" 
                  datetime="2023-10-14T00:00:00Z" 
                  itemprop="datePublished">Oct 14, 2023</time>
        </p>
    </header>
    <div class="post-content e-content" itemprop="articleBody">
        <p>.NET 8, which is currently a preview Release Candidate (RC2) and will be released fully next month, brings about vast changes in the structure of Asp.NET Core Blazor projects. <del>The goal behind these structural changes is to support, from a single project, the ability to render pages and components as static html, server-connected interactive, or WebAssembly-based client interactive.</del> <strong><em>UPDATE: Apparently, .NET 8 does NOT provide a single-project solution for Server and WebAssembly. Instead, in Visual Studio, if you select <code>Auto</code> or <code>WebAssembly</code> rendering, you get a second <code>.Client</code> project. If you create a template from the command line, there is no notification that this is the case, and so you can easily be misled into thinking you can do all the work in one project <a href="https://learn.microsoft.com/en-us/aspnet/core/blazor/project-structure?view=aspnetcore-8.0#blazor-web-app">(Source)</a>.</em></strong> Previously, when developing a project, one would have to choose between Blazor Server and Blazor WebAssembly, and static rendering was not an option.</p>
<p>The new goals are lofty and intriguing, but they come with a lot of challenges for current Blazor developers. The entire setup of a Blazor project has shifted, in both helpful and painful ways. First, I should say, they have not announced any plans to <em>deprecate</em> any of the .NET 6/7 patterns. So if you leave your existing applications alone, they will continue to work on .NET 8. However, if you, like me, are constantly building complex applications that use shared Razor Class Libraries, combine Web APIs with Blazor, or any other pattern where you do not just click <code>File -&gt; New Project</code>, it's important to understand these differences so that you can make informed decisions about your project structure.</p>
<h2 id="project-settings.csproj">Project Settings / .csproj</h2>
<p>We will start with looking at the project settings, which are in the <code>.csproj</code> file.</p>
<h3 id="net-67-blazor-server.csproj">.NET 6/7 Blazor Server .csproj</h3>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&gt;
    &lt;PropertyGroup&gt;
        &lt;TargetFramework&gt;net7.0&lt;/TargetFramework&gt;
    &lt;/PropertyGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>Blazor Server is very straight-forward, requiring no NuGet packages. The <code>.Web</code> SDK brings in all the Asp.NET Core libraries by default.</p>
<h3 id="net-67-blazor-webassembly.csproj">.NET 6/7 Blazor WebAssembly .csproj</h3>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk.BlazorWebAssembly&quot;&gt;
    &lt;PropertyGroup&gt;
        &lt;TargetFramework&gt;net7.0&lt;/TargetFramework&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
        &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Components.WebAssembly&quot; Version=&quot;7.0.12&quot; /&gt;
        &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Components.WebAssembly.DevServer&quot; Version=&quot;7.0.12&quot; PrivateAssets=&quot;all&quot; /&gt;
    &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>WebAssembly projects have a different SDK target than all other Asp.NET Core projects, <code>Microsoft.NET.Sdk.BlazorWebAssembly</code>. They also require specific NuGet references.</p>
<h3 id="net-8-web-app.csproj">.NET 8 Web App .csproj</h3>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&gt;
    &lt;PropertyGroup&gt;
        &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
    &lt;/PropertyGroup&gt;

    &lt;ItemGroup&gt;
        &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Components.WebAssembly.Server&quot; Version=&quot;8.0.0-rc.2.23480.2&quot; /&gt;
    &lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>This is <em>almost</em> the same as Blazor Server. However, if you want to include the ability to manually or automatically move components to WebAssembly, you need the new NuGet reference to <code>WebAssembly.Server</code>.</p>
<p><strong>UPDATE: The Blazor Web App <code>.Client</code> extension project is similar to the .NET 6/7 WebAssembly project. However, you don't need the <code>WebAssembly.DevServer</code> package.</strong></p>
<h2 id="program.cs">Program.cs</h2>
<p>Some of the biggest changes are in the startup code for your project.</p>
<h3 id="net-67-blazor-server-program.cs">.NET 6/7 Blazor Server Program.cs</h3>
<pre><code class="language-csharp">...
WebApplicationBuilder builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();
builder.Services.AddServerSideBlazor();
...

WebApplication app = builder.Build();
...

app.MapBlazorHub();
...

app.Run();
</code></pre>
<p>These are the basic lines that make Blazor Server work. We call <code>AddRazorPages</code> because Blazor server bootstraps itself on top of a Razor Page (<code>_Host.cshtml</code>). Then we explicitly call <code>AddServerSideBlazor</code>, and in the router, we <code>MapBlazorHub</code> to find all routable Razor Components (i.e., Blazor pages).</p>
<h3 id="net-67-blazor-webassembly-program.cs">.NET 6/7 Blazor WebAssembly Program.cs</h3>
<pre><code class="language-csharp">...
WebAssemblyHostBuilder builder = WebAssemblyHostBuilder.CreateDefault(args);

builder.RootComponents.Add&lt;App&gt;(&quot;#app&quot;);
builder.RootComponents.Add&lt;HeadOutlet&gt;(&quot;head::after&quot;);
...

await builder.Build().RunAsync();
</code></pre>
<p>Since the WebAssembly project is built around Blazor, it has a more straightforward hookup, where the <code>builder</code> object accepts <code>RootComponents</code> that are Razor Components.</p>
<h3 id="net-8-blazor-web-app-program.cs">.NET 8 Blazor Web App Program.cs</h3>
<pre><code class="language-csharp">...
WebApplicationBuilder builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents()
    .AddInteractiveWebAssemblyComponents();
...

WebApplication app = builder.Build();
...

app.MapRazorComponents&lt;App&gt;()
    .AddInteractiveServerRenderMode()
    .AddInteractiveWebAssemblyRenderMode();
...

app.Run();
</code></pre>
<p>The Blazor Web App startup includes all new extension methods on both <code>builder</code> and <code>app</code>. <code>AddRazorComponents</code> and <code>MapRazorComponents</code> are both required, but the <code>Interactive</code> methods are optional, and you select these based on which render modes you want to support. One positive improvement over Blazor Server is that we have removed the need to bootstrap from Razor Pages, and instead can directly map routes via the <code>App.razor</code> component.</p>
<p><strong>UPDATE: The .NET 8 Blazor Web App requires a <code>.Client</code> WebAssembly project, which has a very minimal <code>Program.cs</code>, seen below. You cannot use WebAssembly rendering from your main Blazor Web App project.</strong></p>
<pre><code class="language-csharp">using Microsoft.AspNetCore.Components.WebAssembly.Hosting;

var builder = WebAssemblyHostBuilder.CreateDefault(args);

await builder.Build().RunAsync();
</code></pre>
<h2 id="pages-and-components">Pages and Components</h2>
<p>Pages and component differences are more involved to explain the differences. I will focus on what is actually different between versions. At the end, all versions of Blazor support routable Razor Components (Blazor Pages) and nested Razor Components.</p>
<h3 id="net-67-blazor-server-pagescomponents">.NET 6/7 Blazor Server Pages/Components</h3>
<h4 id="host.cshtml">_Host.cshtml</h4>
<pre><code class="language-csharp">@page &quot;/&quot;
@namespace Sample.Server
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
@{
    Layout = &quot;_Layout&quot;;
}

&lt;component type=&quot;typeof(App)&quot; render-mode=&quot;ServerPrerendered&quot;/&gt;
</code></pre>
<p><code>_Host.cshtml</code> is the root Razor Page that receives routing from the Asp.NET Core router. You can see how it calls <code>App</code> as a <code>component</code>.</p>
<h4 id="layout.cshtml">_Layout.cshtml</h4>
<pre><code class="language-html">@using Microsoft.AspNetCore.Components.Web
@namespace Sample.Server
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        ...

        &lt;component type=&quot;typeof(HeadOutlet)&quot; render-mode=&quot;ServerPrerendered&quot; /&gt;
    &lt;/head&gt;
    &lt;body&gt;
        @RenderBody()

        &lt;div id=&quot;blazor-error-ui&quot;&gt;
            &lt;environment include=&quot;Staging,Production&quot;&gt;
                An error has occurred. This application may no longer respond until reloaded.
            &lt;/environment&gt;
            &lt;environment include=&quot;Development&quot;&gt;
                An unhandled exception has occurred. See browser dev tools for details.
            &lt;/environment&gt;
            &lt;a href=&quot;&quot; class=&quot;reload&quot;&gt;Reload&lt;/a&gt;
            &lt;a class=&quot;dismiss&quot;&gt;ðŸ—™&lt;/a&gt;
        &lt;/div&gt;

        &lt;script src=&quot;_framework/blazor.server.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><code>_Layout.cshtml</code> is the root html content that will be used by <code>_Host</code>, including the <code>&lt;head&gt;</code> tag and scripts. Note that <code>@@RenderBody()</code> marks where the <code>_Host</code> content, and therefore its child components, will be rendered.</p>
<h4 id="app.razor-blazor-server">App.razor (Blazor Server)</h4>
<pre><code class="language-html">&lt;Router AppAssembly=&quot;@typeof(App).Assembly&quot;&gt;
    &lt;Found Context=&quot;routeData&quot;&gt;
        &lt;RouteView RouteData=&quot;@routeData&quot; DefaultLayout=&quot;@typeof(MainLayout)&quot; /&gt;
        &lt;FocusOnNavigate RouteData=&quot;@routeData&quot; Selector=&quot;h1&quot; /&gt;
    &lt;/Found&gt;
    &lt;NotFound&gt;
        &lt;PageTitle&gt;Not found&lt;/PageTitle&gt;
        &lt;LayoutView Layout=&quot;@typeof(MainLayout)&quot;&gt;
            &lt;p role=&quot;alert&quot;&gt;Sorry, there's nothing at this address.&lt;/p&gt;
        &lt;/LayoutView&gt;
    &lt;/NotFound&gt;
&lt;/Router&gt;
</code></pre>
<p>This is the first &quot;Blazor&quot;/Razor Component. It manages routing within the Blazor pages. While the name and concept remains across all versions of Blazor, the implementation varies.</p>
<h3 id="net-67-blazor-webassembly-pagescomponents">.NET 6/7 Blazor WebAssembly Pages/Components</h3>
<h4 id="wwwrootindex.html">wwwroot/index.html</h4>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
    ...

&lt;/head&gt;

&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;Loading...&lt;/div&gt;

&lt;div id=&quot;blazor-error-ui&quot;&gt;
    An unhandled error has occurred.
    &lt;a class=&quot;reload&quot; href=&quot;&quot;&gt;Reload&lt;/a&gt;
    &lt;a class=&quot;dismiss&quot;&gt;ðŸ—™&lt;/a&gt;
&lt;/div&gt;
&lt;script src=&quot;_framework/blazor.webassembly.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>Since Blazor WebAssembly renders in the browser, it must start with pre-rendered html. The call to load the <code>blazor.webassembly.js</code> script is what kicks off all interactivity. The <code>&lt;div id=&quot;app&quot;&gt;</code> is the placeholder where <code>App.razor</code> will be rendered once the WebAssembly code is loaded.</p>
<h4 id="app.razor-blazor-webassembly">App.razor (Blazor WebAssembly)</h4>
<pre><code class="language-html">&lt;Router AppAssembly=&quot;@typeof(App).Assembly&quot;&gt;
    &lt;Found Context=&quot;routeData&quot;&gt;
        &lt;RouteView RouteData=&quot;@routeData&quot; DefaultLayout=&quot;@typeof(MainLayout)&quot; /&gt;
        &lt;FocusOnNavigate RouteData=&quot;@routeData&quot; Selector=&quot;h1&quot; /&gt;
    &lt;/Found&gt;
    &lt;NotFound&gt;
        &lt;PageTitle&gt;Not found&lt;/PageTitle&gt;
        &lt;LayoutView Layout=&quot;@typeof(MainLayout)&quot;&gt;
            &lt;p role=&quot;alert&quot;&gt;Sorry, there's nothing at this address.&lt;/p&gt;
        &lt;/LayoutView&gt;
    &lt;/NotFound&gt;
&lt;/Router&gt;
</code></pre>
<p>The <code>App.razor</code> in WebAssembly is identical in structure and function to the one in Blazor Server.</p>
<h3 id="net-8-blazor-web-app-pagescomponents">.NET 8 Blazor Web App Pages/Components</h3>
<p>As mentioned above, one of the nice features of Blazor Web Apps is the direct routing to Razor Components. <code>App.razor</code> now takes on the brunt of the html setup.</p>
<h4 id="app.razor-blazor-web-app">App.razor (Blazor Web App)</h4>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

    &lt;head&gt;
        ...

        &lt;HeadOutlet @rendermode=&quot;@InteractiveAuto&quot; /&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;Routes @rendermode=&quot;@InteractiveAuto&quot; /&gt;
        &lt;script src=&quot;_framework/blazor.web.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>Two things to note here. First, <code>@@rendermode</code>, which is optional, will set the render mode for all child pages and components. See <a href="https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-8.0">ASP.NET Core Blazor render modes</a> to learn more about these options. If you want the &quot;old&quot; behavior of Blazor Server in a Blazor Web App, you should be able to set  <code>@@rendermode=&quot;InteractiveServer&quot;</code>. (I am still testing this to see if it is really a 1-1 comparison). Also note that, <em>by default, if you don't set a render mode, Blazor Web Apps have no interactivity!</em> This means that <code>EventCallbacks</code> and click handlers simply don't work, <em>by default</em> in a Blazor Web App. The new default is completely statically-rendered server pages. In my opinion, this is the biggest failing of Blazor moving into .NET 8, as it undermines the <em>entire point</em> of using Blazor for rich web development.</p>
<p>The second point of interest is that the bulk of the old <code>App.razor</code> functionality, namely routing, has been moved into a child component named <code>Routes</code>.</p>
<h4 id="routes.razor">Routes.razor</h4>
<pre><code class="language-html">&lt;Router AppAssembly=&quot;@typeof(Program).Assembly&quot;&gt;
    &lt;Found Context=&quot;routeData&quot;&gt;
        &lt;RouteView RouteData=&quot;@routeData&quot; DefaultLayout=&quot;@typeof(MainLayout)&quot; /&gt;
        &lt;FocusOnNavigate RouteData=&quot;@routeData&quot; Selector=&quot;h1&quot; /&gt;
    &lt;/Found&gt;
&lt;/Router&gt;
</code></pre>
<p><strong>UPDATE: The Blazor Web App <code>.Client</code> project has only the <code>Routes.razor</code> part of the structure described above, when targeting WebAssembly. The rest remains in the main project.</strong></p>
<h2 id="sharing-components-in-razor-class-libraries">Sharing Components in Razor Class Libraries</h2>
<p>One of my biggest frustrations with the new Blazor Web App is that it makes it much more difficult to reason about, and even share, Razor Components in a Razor Class Library. Especially with the pattern of defining the <code>@@rendermode</code> <em>inside</em> the component. Will Blazor Hybrid in MAUI ignore these declarations? What about a shared Blazor WebAssembly executable? Until I found the explanation above about how to set the render mode at the <code>App.razor</code> level, I wasn't even sure if you <em>could</em> use previously-generated, routable components from a library.</p>
<p>One other catch. In .NET 6/7, this is how we told Blazor to find components from an RCL, in <code>App.razor</code>:</p>
<pre><code class="language-html">&lt;Router AppAssembly=&quot;@typeof(App).Assembly&quot;
        AdditionalAssemblies=&quot;new[] { typeof(MyRclComponent).Assembly }&quot;&gt;
...
</code></pre>
<p>This works for Blazor Server, Blazor WebAssembly, and Blazor Hybrid (MAUI). However, in Blazor Web Apps, you need to add the following line to <code>Program.cs</code>:</p>
<pre><code class="language-csharp">app.MapRazorComponents&lt;App&gt;()
    .AddInteractiveServerRenderMode()
    .AddInteractiveWebAssemblyRenderMode()
    .AddAdditionalAssemblies(typeof(MyRclComponent).Assembly);
</code></pre>
<h2 id="looking-forward">Looking Forward</h2>
<p>I am still a huge fan of Asp.NET Core Blazor, and I think there were a lot of great improvements in .NET 8. While I am <em>very</em> frustrated by the default behavior changing from interactive to static components, I hope that this will be better exposed and highlighted through IDE and compile-time warnings. For example, if I compile a Razor Component with <code>@@onclick</code> handlers, and the compiler and/or IDE can tell it is referenced to be rendered statically, this should generate a warning, so I know that my handlers are not going to work.</p>
<p>I'm also concerned about managing user state in Blazor Web Apps. Rockford Lhotka published an <a href="https://blog.lhotka.net/2023/10/12/Blazor-8-State-Management">excellent blog post</a> about this issue. Given the combination of user state and shared RCL code in most of my business projects, I am likely to stick with top-level <code>rendermode</code> set to <code>InteractiveServer</code> or <code>InteractiveWebAssembly</code> (assuming this works like current Wasm (<strong>UPDATE: It doesn't, see other updates</strong>)) for the foreseeable future, and rarely if ever use the complex mix of rendering modes now available. It will be interesting to see what .NET 9 brings. Hopefully, nothing near this year's complexity of changes!</p>
<p><strong>UPDATE: The discovery, by switching from command line to Visual Studio, of the required additional WebAssembly project makes .NET 8 Blazor Web Apps even <em>less</em> appealing as the &quot;new way&quot;. What, exactly, did we gain over the old patterns? Apparently just static rendering and first-class routing. And in return, we give up the clear paths of sharing code across projects. I'm not at all clear yet how I would set up a Blazor Web App that supports Server and WebAssembly rendering and also shares components with MAUI. Maybe it's not as hard as it seems, but as someone who reads <em>obsessively</em> about Blazor, and attended MS Build last spring, I must say, the lack of clarity in the CLI tools and documentation are incredibly frustrating.</strong></p>
<p>Feel free to ping me on Mastodon <a href="https://dotnet.social/@@TimPurdum">@@TimPurdum@@dotnet.social</a> if you want to geek out about Blazor!</p>

    </div>
</article>