@page "/post/2023/7/22/linq-and-javascript"
<PageTitle>LINQ Equivalents in JavaScript</PageTitle>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
    <header class="post-header">
        <h1 class="post-title p-name" itemprop="name headline">LINQ Equivalents in JavaScript</h1>
        <h2 class="post-subtitle" itemprop="name subtitle">Move Seamlessly Between Languages</h2>
        <p class="post-meta">
            <time class="dt-published" 
                  datetime="2023-07-22T00:00:00Z" 
                  itemprop="datePublished">Jul 22, 2023</time>
        </p>
    </header>
    <div class="post-content e-content" itemprop="articleBody">
        <p><a href="https://blog.dymaptic.com/c-linq-equivalents-in-javascript">Originally posted on the dymaptic blog on June 16, 2023</a></p>
<p>When I'm working on <a href="www.geoblazor.com">GeoBlazor</a> or other Blazor applications, I often have to switch between C# and JavaScript/TypeScript. While the two languages have a <em>lot</em> in common (C family syntax, async/await, lambda functions), one place I often get confused is when dealing with arrays or collections of items. In C#, the most straightforward way to do this is with <a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable"><code>LINQ</code> queries</a>. Most of these query methods work on any collection type, including <code>Array</code>, <code>List</code>, <code>ReadOnlyList</code>, <code>HashSet</code>, and the related interfaces. The root interface necessary is <code>IEnumerable</code>.</p>
<p>With ES6 and later versions, JavaScript has adopted many of these same approaches as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">methods on the <code>Array</code> class</a>, using <code>Array.prototype</code> (<a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes">prototype is the JavaScript concept of inheritance</a>).</p>
<p><img src="/images/C-Sharp-LINQ.jpg" alt="C# LINQ to JavaScript Equivalents" /></p>
<p>In this post, I am going to discuss all of the methods of <code>IEnumerable</code> in <code>LINQ</code> and their JavaScript equivalents. Some of these methods are very common, while others, such as the <a href="https://exceptionnotfound.net/bite-size-dotnet-6-unionby-intersectby-exceptby-and-distinctby/">new .NET 6 <code>...By</code> methods</a>, are less well known. I'm also not going to deal with every possible parameter overload, as many LINQ methods allow for custom <code>IComparer</code> implementations or other optional parameters. In most cases, you will see that JavaScript has fewer methods than C#, but that they can be used in many of the same ways. It is also important to note that all <code>IEnumerable</code> methods return a <em>new</em> collection, and do not modify the original input collection. C# does have mutable collection methods, for example on the <code>List</code> class, such as <code>Add</code>, <code>Remove</code>, <code>Sort</code>, but these are kept distinct from the LINQ methods to make it clearer when you are mutating the original value. In JavaScript, both mutating and functional methods exist on <code>Array.prototype</code>. In fact, there is a recent collection of new methods that <em>only</em> return a new array, such as <code>toSorted</code>, <code>toReversed</code>, and <code>toSpliced</code>, but these are <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSpliced#browser_compatibility">not yet implemented in all major browsers</a> at the time of writing. In the comparison chart, I do use several mutating array methods, but only because there is no functional equivalent in JavaScript to compare to LINQ.</p>
<p>If you want to skip to the comparison table to look up a method, <a href="#comparison-chart">jump to the end of this post</a>.</p>
<h2 id="creating-a-new-collection">Creating a new Collection</h2>
<p>In both languages, you can easily create a new collection. <code>new List&lt;T&gt;()</code> in C#, or <code>[]</code> in JavaScript, for example. C# also has the following convenience static methods on <code>IEnumerable</code> to generate a new collection.</p>
<h3 id="c">C#</h3>
<ul>
<li><code>Empty</code> - Creates a new, empty <code>IEnumerable</code> instance.</li>
<li><code>Range</code> - Creates a new collection of sequential intervals, with a given start index and count.</li>
<li><code>Repeat</code> - Generates a new collection with the same item repeated a given <code>Count</code> times.</li>
</ul>
<h2 id="finding-a-single-record">Finding a Single Record</h2>
<h3 id="c-1">C#</h3>
<ul>
<li><code>ElementAt</code> - Finds the element at a particular index. Similar to using an indexer (e.g., <code>array[index]</code>). Throws if the index is out of range.</li>
<li><code>ElementAtOrDefault</code> - Like <code>ElementAt</code> but returns <code>default</code> (<code>null</code> for nullable types) if the index is out of range.</li>
<li><code>First</code> - Finds the first item that matches the predicate. Throws on no match.</li>
<li><code>FirstOrDefault</code> - Like <code>First</code> but returns <code>default</code> if no match is found.</li>
<li><code>Last</code> - Finds the <em>last</em> item that matches the predicate. Throws on no match.</li>
<li><code>LastOrDefault</code> - Like <code>Last</code> but returns <code>default</code> if no match is found.</li>
<li><code>Max</code> - Returns the item with the highest numeric value.</li>
<li><code>MaxBy</code> - Returns the item with the highest <code>Key</code> value according to the given <code>IComparer</code>.</li>
<li><code>Min</code> - Returns the item with the lowest numeric value.</li>
<li><code>MinBy</code> - Returns the item with the lowest <code>Key</code> value according to the given <code>IComparer</code>.</li>
<li><code>Single</code> - Like <code>First</code> but also throws if multiple matches are found.</li>
<li><code>SingleOrDefault</code> Like <code>FirstOrDefault</code> but also throws if multiple matches are found.</li>
</ul>
<p>As you can see, each method comes in two flavors, <code>null</code>-forgiving, and <code>null</code>-throwing. Like <a href="https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references">Nullable Reference Types</a>, this is useful for explicitly declaring your intentions, and not accidentally returning a <code>null</code> where you really expected there to be a value. The <code>Single</code> methods also verify that you have exactly one match in your collection.</p>
<h3 id="javascript">JavaScript</h3>
<ul>
<li><code>at</code> - Finds the element at a particular index.</li>
<li><code>find</code> - Finds the first element that matches the predicate.</li>
<li><code>findLast</code> - Finds the <em>last</em> element that matches the predicate.</li>
</ul>
<p>In JavaScript, we have fewer methods that return a single value. Unlike in C#, JavaScript never throws errors if it fails to find an item. Instead, all of these methods return an <code>undefined</code> value if a match is not found. There is also no equivalent of <code>Single</code> in JavaScript. Instead, you would have to <code>filter</code> and then <code>throw</code> if you found more than one match.</p>
<h2 id="finding-or-filtering-multiple-records">Finding or Filtering Multiple Records</h2>
<h3 id="c-2">C#</h3>
<ul>
<li><code>Distinct</code> - Removes any duplicate entries and returns a collection in which each entry is unique.</li>
<li><code>DistinctBy</code> - Removes entries with duplicate <code>Key</code> values.</li>
<li><code>Except</code> - Returns all items from the first collection that are <em>not</em> in the second collection.</li>
<li><code>ExceptBy</code> - Returns all items from the first collection that do <em>not</em> have a matching <code>Key</code> value in the second collection.</li>
<li><code>Intersect</code> - Compares two collections and returns all items that are present in both.</li>
<li><code>IntersectBy</code> - Compares two collections and returns all items that have matching <code>Key</code> values in both.</li>
<li><code>OfType&lt;T&gt;</code> - Filters the collection to only records of a particular <code>Type</code>.</li>
<li><code>Skip</code> - Skips a specified number of records, and then returns the rest of the collection.</li>
<li><code>SkipLast</code> - Returns the collection minus the specified number of records at the end.</li>
<li><code>SkipWhile</code> - Skips forward over the collection until the predicate is <code>false</code>, and then returns the rest of the collection.</li>
<li><code>Take</code> - Returns the first specified number of elements in the collection.</li>
<li><code>TakeLast</code> - Returns the specified number of elements from the end of the collection.</li>
<li><code>TakeWhile</code> - Returns all elements from the start of the collection until the predicate is <code>false</code>.</li>
<li><code>Where</code> - Finds all matches to the predicate. If none found, returns an empty IEnumerable.</li>
</ul>
<h3 id="javascript-1">JavaScript</h3>
<ul>
<li><code>filter</code> - Finds all matches to the predicate. If none found, returns an empty array.</li>
<li><code>slice</code> - Returns a sub-section of the collection by start index and optional end index.</li>
</ul>
<p>Once again, C# has multipe methods that can filter a collection, whereas JavaScript has just the one. Yet you can easily <code>filter</code> on class type or the contents of a second array.</p>
<h2 id="sorting-records">Sorting Records</h2>
<h3 id="c-3">C#</h3>
<ul>
<li><code>Order</code> - Sorts the items by their default comparison in ascending order.</li>
<li><code>OrderBy</code> - Sorts the items by a <code>Key</code> value in ascending order.</li>
<li><code>OrderByDescending</code> - Sorts the items by a <code>Key</code> value in descending order.</li>
<li><code>OrderDescending</code> - Sorts the items by their default comparison in descending order.</li>
<li><code>Reverse</code> - Returns a collection in the opposite order from the original.</li>
<li><code>ThenBy</code> - Used to chain sorting calls with any <code>Order</code>, <code>OrderBy</code> or other <code>ThenBy</code> call. Sorts by a new <code>Key</code> ascending.</li>
<li><code>ThenByDescending</code> - Used to chain sorting calls with any <code>Order</code>, <code>OrderBy</code> or other <code>ThenBy</code> call. Sorts by a new <code>Key</code> descending.</li>
</ul>
<h3 id="javascript-2">JavaScript</h3>
<ul>
<li><code>sort</code> - Sorts the items by their default order or a comparison function. Mutates the original array.</li>
<li><code>reverse</code> - Returns the array in the opposite order from the original. Mutates the original array.</li>
</ul>
<h2 id="combining-or-adding-to-collections">Combining or Adding to Collections</h2>
<h3 id="c-4">C#</h3>
<ul>
<li><code>Append</code> - Adds a new item to the end of the collection.</li>
<li><code>Concat</code> - Adds a new collection to the end of the first collection.</li>
<li><code>Join</code> - Combines two collections, based on a defined <code>Key</code> in each, and a custom function to join the two together.</li>
<li><code>Prepend</code> - Adds a new item to the beginning of the collection.</li>
<li><code>Union</code> - Combines two collections, excluding duplicates.</li>
<li><code>UnionBy</code> - Combines two collections, limiting each <code>Key</code> to a single instance.</li>
</ul>
<h3 id="javascript-3">JavaScript</h3>
<ul>
<li><code>concat</code> - Adds a new array to the end of the first array. Does not alter the existing arrays.</li>
<li><code>push</code> - Adds a new item to the end of the array, and returns the new <code>length</code>.</li>
<li><code>unshift</code> - Adds a new item to the beginning of the array, and returns the new <code>length</code>.</li>
</ul>
<h2 id="boolean-methods">Boolean Methods</h2>
<p>These methods return a <code>true</code> or <code>false</code> depending on what is in the collection.</p>
<h3 id="c-5">C#</h3>
<ul>
<li><code>All</code> - Returns <code>true</code> if all items match the predicate.</li>
<li><code>Any</code> - Returns <code>true</code> if any item matches the predicate.</li>
<li><code>Contains</code> - Returns <code>true</code> if the item is in the collection.</li>
<li><code>SequenceEqual</code> - Compares each item in two collections, and returns <code>true</code> if they all match.</li>
</ul>
<h3 id="javascript-4">JavaScript</h3>
<ul>
<li><code>every</code> - Returns <code>true</code> if all items match the predicate.</li>
<li><code>includes</code> - Returns <code>true</code> if the item is in the array.</li>
<li><code>some</code> - Returns <code>true</code> if any item matches the predicate.</li>
</ul>
<h2 id="counting-and-transforming-items">Counting and Transforming Items</h2>
<p>There are many transformations possible on a collection of items, especially on numeric types. These methods can be very powerful, and are in my opinion the hardest to keep straight in terms of different names. For example, <code>Aggregate</code>, and <code>reduce</code> seem like opposite terms, yet they are actually the same concept! <code>Select</code> and <code>map</code> are probably the most common transformation in each language, so it is important to know how to use them well.</p>
<h3 id="c-6">C#</h3>
<ul>
<li><code>Aggregate</code> - Applies an <code>Accumulator</code> function to the collection, where each item and the accumulation are passed as parameters. Also supports giving a starting <code>seed</code> value.</li>
<li><code>Average</code> - Finds the numeric average of the collection values.</li>
<li><code>Count</code> - Returns the number of collection items as an <code>int</code>.</li>
<li><code>LongCount</code> - Returns the number of collection items as a <code>long</code>.</li>
<li><code>Select</code> - Transforms each item in the collection via a custom function into a new value.</li>
<li><code>SelectMany</code> - Transforms each item in the collection into a new <em>collection</em> of values, which are then flattened into a single new collection.</li>
<li><code>Sum</code> - Adds all the values together for the collection.</li>
<li><code>TryGetNonEnumeratedCount</code> - Attempts to count the items in the collection without actually enumerating the items. Returns a boolean to indicate success, and has an <code>out</code> parameter with the count value.</li>
<li><code>Zip</code> - Uses a custom function to combine each item in two collections together by index.</li>
</ul>
<h3 id="javascript-5">JavaScript</h3>
<ul>
<li><code>flatMap</code> - Transforms each item in the collection into a new <em>array</em> of values, which are then flattened into a single array.</li>
<li><code>length</code> - Returns the number of items in the array.</li>
<li><code>map</code> - Transforms each item in the array via a custom function into a new value.</li>
<li><code>reduce</code> - Applies an <code>accumulator</code> function to the array, where each item and the accumulation are passed as parameters. Also supports an <code>initialValue</code>.</li>
</ul>
<h2 id="c-only-type-transformations">C#-Only Type Transformations</h2>
<p>These methods do not have a JavaScript equivalent because JS is a loosely-typed language. Instead, you can simply <em>treat</em> one type like another, and if it has the correct properties and methods, it will work. In C#, not only do you need to cast to the appropriate collection type for some usages, but since many LINQ methods use <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/classification-of-standard-query-operators-by-manner-of-execution#deferred">deferred execution</a>, this also forces the query to actually run and produce an in-memory collection.</p>
<ul>
<li><code>AsEnumerable</code> - Returns the collection as an <code>IEnumerable&lt;T&gt;</code>.</li>
<li><code>Cast&lt;T&gt;</code> - Returns the collection with each item cast to the <code>T</code> value in an <code>IEnumerable&lt;T&gt;</code>.</li>
<li><code>DefaultIfEmpty</code> - Returns the original collection, or if the collection was empty, returns a new collection with a single, default value (e.g., <code>null</code>).</li>
<li><code>ToArray</code> - Returns a fixed-length array.</li>
<li><code>ToDictionary</code> - Transforms a simple collection into a Key/Value pair Dictionary.</li>
<li><code>ToHashSet</code> - Returns a collection with no duplicates, similar to <code>Distinct</code>, but the <code>HashSet</code> type prevents adding duplicates in the future as well.</li>
<li><code>ToList</code> - Returns a mutable list that can be added to or removed from.</li>
<li><code>ToLookup</code> - Groups the collection under <code>key</code> lookup values.</li>
</ul>
<h2 id="c-only-grouping-records">C#-Only Grouping Records</h2>
<ul>
<li><code>Chunk</code> - Creates a collection of arrays, of a fixed maximum size, from the original collection.</li>
<li><code>GroupBy</code> - Creates a collection of <code>IGrouping</code> elements, each of which is a collection of items from the original collection grouped by a predicate.</li>
<li><code>GroupJoin</code> - Creates a new collection, normally with a different <code>Type</code>, that contains the joined results of two collections.</li>
</ul>
<h2 id="comparison-chart">Comparison Chart</h2>
<p>In the following chart, I aimed for a 1-1 comparison whenever possible. If there was no JavaScript Array method, I tried to find the most succinct way of achieving the same result in code.</p>
<p>C# LINQ <code>IEnumerable</code> Method</p>
<p>JavaScript <code>Array.prototype</code> Method</p>
<p><code>Aggregate((acc, x) =&gt; function, seed)</code></p>
<p><code>reduce((acc, x) =&gt; function, seed)</code></p>
<p><code>All(x =&gt; predicate)</code></p>
<p><code>every(x =&gt; predicate)</code></p>
<p><code>Any(x =&gt; predicate)</code></p>
<p><code>some(x =&gt; predicate)</code></p>
<p><code>Append(item)</code></p>
<p><code>push(item)</code></p>
<p><code>AsEnumerable()</code></p>
<p>N/A</p>
<p><code>Average()</code></p>
<p><code>reduce((acc, x) =&gt; acc + x) / array.length</code></p>
<p><code>Cast&lt;T&gt;()</code></p>
<p>N/A</p>
<p><code>Chunk(size)</code></p>
<p>no simple equivalent</p>
<p><code>Concat(otherIEnumerable)</code></p>
<p><code>concat(otherArray)</code></p>
<p><code>Contains(item)</code></p>
<p><code>includes(item)</code></p>
<p><code>Count()</code></p>
<p><code>length</code></p>
<p><code>DefaultIfEmpty()</code></p>
<p><code>some() ? array : undefined</code></p>
<p><code>Distinct()</code></p>
<p><code>[...new Set(array)]</code> <sup>2</sup></p>
<p><code>DistinctBy(x =&gt; x.Key)</code></p>
<p>no simple equivalent</p>
<p><code>ElementAt(index)</code></p>
<p><code>at(index)</code></p>
<p><code>ElementAtOrDefault(index)</code></p>
<p><code>at(index)</code></p>
<p><code>Empty&lt;T&gt;()</code> <sup>1</sup></p>
<p><code>[]</code> <sup>2</sup></p>
<p><code>Except(otherIEnumerable)</code></p>
<p><code>filter(x =&gt; !otherArray.includes(x))</code></p>
<p><code>ExceptBy(other, x =&gt; x.Key)</code></p>
<p>no simple equivalent</p>
<p><code>First(x =&gt; predicate)</code></p>
<p><code>find(x =&gt; predicate)</code></p>
<p><code>FirstOrDefault(x =&gt; predicate)</code></p>
<p><code>find(x =&gt; predicate)</code></p>
<p><code>GroupBy(x =&gt; predicate)</code></p>
<p>no simple equivalent <sup>3</sup></p>
<p><code>GroupJoin(inner, o =&gt; o.Key, i =&gt; i.Key, func, comparer)</code></p>
<p>no simple equivalent</p>
<p><code>Intersect(other)</code></p>
<p><code>filter(x =&gt; otherArray.includes(x))</code></p>
<p><code>IntersectBy(other, x =&gt; x.Key, comparer)</code></p>
<p>no simple equivalent</p>
<p><code>Join(inner, o =&gt; o.Key, i =&gt; i.Key, func)</code></p>
<p>no simple equivalent</p>
<p><code>Last(x =&gt; predicate)</code></p>
<p><code>findLast(x =&gt; predicate)</code></p>
<p><code>LastOrDefault(x =&gt; predicate)</code></p>
<p><code>findLast(x =&gt; predicate)</code></p>
<p><code>LongCount()</code></p>
<p><code>length</code></p>
<p><code>Max()</code></p>
<p><code>Math.max(...array)</code> <sup>2</sup></p>
<p><code>MaxBy(x =&gt; x.Key)</code></p>
<p><code>sort((a, b) =&gt; b.Key - a.Key)[0]</code></p>
<p><code>Min()</code></p>
<p><code>Math.min(...array)</code> <sup>2</sup></p>
<p><code>MinBy(x =&gt; x.Key)</code></p>
<p><code>sort((a, b) =&gt; a.Key - b.Key)[0]</code></p>
<p><code>OfType&lt;T&gt;()</code></p>
<p><code>filter(x =&gt; x instanceof T)</code></p>
<p><code>Order()</code></p>
<p><code>sort()</code> <sup>4</sup></p>
<p><code>OrderBy(x =&gt; x.Key)</code></p>
<p><code>sort((a, b) =&gt; a.key - b.key)</code> <sup>4</sup></p>
<p><code>OrderByDescending(x =&gt; x.Key)</code></p>
<p><code>sort((a, b) =&gt; b.key - a.key)</code> <sup>4</sup></p>
<p><code>OrderDescending()</code></p>
<p><code>sort((a, b) =&gt; b - a)</code> <sup>4</sup></p>
<p><code>Prepend(item)</code></p>
<p><code>unshift(item)</code> <sup>4</sup></p>
<p><code>Range(start, count)</code> <sup>1</sup></p>
<p><code>[...Array(count + start).keys()].slice(start)</code> <sup>2</sup></p>
<p><code>Repeat(item, count)</code> <sup>1</sup></p>
<p><code>fill(item, startIndex, endIndex)</code> <sup>4</sup></p>
<p><code>Reverse()</code></p>
<p><code>reverse()</code> <sup>4</sup></p>
<p><code>Select(x =&gt; function)</code></p>
<p><code>map(x =&gt; function)</code></p>
<p><code>SelectMany(x =&gt; function)</code></p>
<p><code>flatMap(x =&gt; function)</code></p>
<p><code>SequenceEqual(otherIEnumerable)</code></p>
<p>no simple equivalent</p>
<p><code>Single(x =&gt; predicate)</code></p>
<p><code>filter(x =&gt; predicate); result.length &gt; 1 ? throw error;</code></p>
<p><code>SingleOrDefault(x =&gt; predicate)</code></p>
<p><code>filter(x =&gt; predicate); result.length &gt; 1 ? throw error;</code></p>
<p><code>Skip(count)</code></p>
<p><code>slice(count)</code></p>
<p><code>SkipLast(count)</code></p>
<p><code>slice(0, -count)</code></p>
<p><code>SkipWhile(x =&gt; predicate)</code></p>
<p>no simple equivalent</p>
<p><code>Sum()</code></p>
<p><code>reduce((acc, x) =&gt; acc + x)</code></p>
<p><code>Take(count)</code></p>
<p><code>slice(0, count)</code></p>
<p><code>TakeLast(count)</code></p>
<p><code>slice(-count)</code></p>
<p><code>TakeWhile(x =&gt; predicate)</code></p>
<p>no simple equivalent</p>
<p><code>ThenBy(x =&gt; x.Key)</code></p>
<p>no simple equivalent</p>
<p><code>ThenByDescending(x =&gt; x.Key)</code></p>
<p>no simple equivalent</p>
<p><code>ToArray()</code></p>
<p>N/A</p>
<p><code>ToDictionary(x =&gt; function, x =&gt; function)</code></p>
<p><code>reduce((acc, x, i) =&gt; acc[functionK] = functionV)</code></p>
<p><code>ToHashSet()</code></p>
<p><code>new Set(array)</code> <sup>2</sup></p>
<p><code>ToList()</code></p>
<p>N/A</p>
<p><code>ToLookup(x =&gt; function, x =&gt; function)</code></p>
<p>no simple equivalent</p>
<p><code>TryGetNonEnumerated(out int count)</code></p>
<p>no simple equivalent</p>
<p><code>Where(x =&gt; predicate)</code></p>
<p><code>filter(x =&gt; predicate)</code></p>
<p><code>Union(otherIEnumerable)</code></p>
<p><code>[...new Set(array.concat(otherArray))]</code></p>
<p><code>UnionBy(other, x =&gt; x.Key)</code></p>
<p>no simple equivalent</p>
<p><code>Zip(other, (a, b) =&gt; function)</code></p>
<p><code>map((a, i) =&gt; functionWithOther[i])</code></p>
<p><sup>1</sup> - <em>static method on <code>Enumerable</code></em><br/>
<sup>2</sup> - <em>not a method on <code>Array.prototype</code></em><br/>
<sup>3</sup> - <em><code>group</code> method is in experimental stage</em><br/>
<sup>4</sup> - <em>mutates the original array</em><br/></p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope this deep dive into LINQ functional methods and their JavaScript Array counterparts was useful. If you are a .NET Blazor developer or interested in GeoSpatial Information Systems (GIS), checkout <a href="https://geoblazor.com">GeoBlazor</a> and the <a href="https://blog.dymaptic.com">dymaptic blog</a> for more content!</p>

    </div>
</article>